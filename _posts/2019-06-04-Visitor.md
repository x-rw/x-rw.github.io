---
layout: post
title: Visitor Pattern
categories: [bloggy]
---

Por lo tanto, es probable que haya leído más de un billón de explicaciones diferentes del patrón de visitantes, y probablemente todavía esté diciendo "¡pero cuándo lo usaría!"

Tradicionalmente, los visitantes se utilizan para implementar pruebas de tipo sin sacrificar la seguridad de tipo, siempre y cuando sus tipos estén bien definidos por adelantado y se conozcan de antemano. Digamos que tenemos algunas clases de la siguiente manera:

```java
abstract class Fruit { }
class Orange : Fruit { }
class Apple : Fruit { }
class Banana : Fruit { }
```
Y digamos que creamos un Fruit[]:
```java
var fruits = new Fruit[]
    { new Orange(), new Apple(), new Banana(),
      new Banana(), new Banana(), new Orange() };
```
Quiero dividir la lista en tres listas, cada una de las cuales contiene naranjas, manzanas o bananas. ¿Como lo harias? Bueno, la solución fácil sería una prueba de tipo:
```java
List<Orange> oranges = new List<Orange>();
List<Apple> apples = new List<Apple>();
List<Banana> bananas = new List<Banana>();
foreach (Fruit fruit in fruits)
{
    if (fruit is Orange)
        oranges.Add((Orange)fruit);
    else if (fruit is Apple)
        apples.Add((Apple)fruit);
    else if (fruit is Banana)
        bananas.Add((Banana)fruit);
}
```
Funciona, pero hay muchos problemas con este código:

Para empezar, es feo.
No es seguro para el tipo, no detectaremos errores de tipo hasta el tiempo de ejecución.
No es mantenible. Si agregamos una nueva instancia derivada de Fruit, debemos hacer una búsqueda global para cada lugar que realice una prueba de tipo de fruta, de lo contrario, podríamos pasar por alto los tipos.
Patrón de visitante resuelve el problema con elegancia.

```java
public class Book implements ShoppingCarElement{

    private int price;
    private String insbnNumber;
    
    public Book(int cost, String isbn){
    this.price=cost;
    this.insbnNumber=isbn;
    }
    
    public int getPrice(){
    return price;
    }
    
    public String getIsString(){
    return insbnNumber;
    }
    
    @Override
    public int accept(ShoppingCartVisitor visitor) {
        return visitor.visit(this);
    }
    
}
```


```java
public interface ShoppingCarElement {
    int accept(ShoppingCartVisitor visitor);
}




public interface ShoppingCartVisitor {
   int visit(Book book);
   int visit(Fruit fruit);
}
```





```java
public class ShoppingCartVisitorImpl  implements  ShoppingCartVisitor{

    @Override
    public int visit(Book book) {
      int cost=0;
      if(book.getPrice()>50){
          cost=book.getPrice()-5;
      }else{
         cost=book.getPrice();     
      }
      return cost;
    }

    @Override
    public int visit(Fruit fruit) {
        int cost=fruit.getPricePerKg()*fruit.getWeight();
        return cost;
    }
    
}

```



```java
public class VisitorTest {

    public static void main(String args[]) {
        ShoppingCarElement[] items = new ShoppingCarElement[]{ new Book(10, "111"), new Book(11, "222"),new Fruit(29, 80, "sss")};
        int total = calculatePrice(items);
    }

    private static int calculatePrice(ShoppingCarElement[] items) {
        ShoppingCartVisitor visitor = new ShoppingCartVisitorImpl();
        int sum = 0;
        for (ShoppingCarElement item : items) {
            sum = sum + item.accept(visitor);
        }
        System.out.println("SUMA" + sum);
        return sum;
    }

}

```
